import asyncio
import logging
from typing import Optional, Tuple

from aiogram import types, F
from aiogram.exceptions import TelegramBadRequest, TelegramForbiddenError, TelegramRetryAfter
from aiogram.filters import Command
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import State, StatesGroup
from aiogram.types import InlineKeyboardButton, InlineKeyboardMarkup

from config import ADMIN_IDS, bot, dp
from database import (
    add_channel,
    fetch_channel,
    fetch_channels,
    get_all_user_ids,
    get_reward_stats,
    get_user_count,
    set_channel_active,
    update_channel,
)


class AddChannelStates(StatesGroup):
    waiting_for_chat_identifier = State()
    waiting_for_invite_link = State()
    waiting_for_magnet_type = State()
    waiting_for_magnet_payload = State()
    waiting_for_caption = State()


class EditMagnetStates(StatesGroup):
    waiting_for_channel_choice = State()
    waiting_for_magnet_type = State()
    waiting_for_magnet_payload = State()
    waiting_for_caption = State()


class DeleteChannelStates(StatesGroup):
    waiting_for_channel_choice = State()
    waiting_for_confirmation = State()


class BroadcastStates(StatesGroup):
    waiting_for_content_type = State()
    waiting_for_content = State()
    waiting_for_button = State()
    waiting_for_confirmation = State()


MAGNET_TYPES = {
    "document": "üìé –§–∞–π–ª",
    "link": "üîó –°—Å—ã–ª–∫–∞",
    "text": "üìù –¢–µ–∫—Å—Ç",
    "photo": "üñº –ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ",
}

BROADCAST_TYPES = {
    "text": "üìù –¢–µ–∫—Å—Ç",
    "photo": "üñº –§–æ—Ç–æ",
    "video": "üé• –í–∏–¥–µ–æ",
    "document": "üìé –§–∞–π–ª",
}


async def send_admin_menu(event: types.Message | types.CallbackQuery):
    """–û—Ç–ø—Ä–∞–≤–ª—è–µ—Ç –∏–ª–∏ –æ–±–Ω–æ–≤–ª—è–µ—Ç –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞."""
    keyboard = InlineKeyboardMarkup(
        inline_keyboard=[
            [InlineKeyboardButton(text="‚ûï –î–æ–±–∞–≤–∏—Ç—å –∫–∞–Ω–∞–ª", callback_data="admin:add")],
            [InlineKeyboardButton(text="‚úèÔ∏è –ò–∑–º–µ–Ω–∏—Ç—å –ª–∏—Ç–º–∞–≥–Ω–∏—Ç", callback_data="admin:edit")],
            [InlineKeyboardButton(text="üóë –£–¥–∞–ª–∏—Ç—å –∫–∞–Ω–∞–ª", callback_data="admin:delete")],
            [InlineKeyboardButton(text="üìã –°–ø–∏—Å–æ–∫ –∫–∞–Ω–∞–ª–æ–≤", callback_data="admin:list")],
            [InlineKeyboardButton(text="üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞", callback_data="admin:stats")],
            [InlineKeyboardButton(text="üì® –†–∞—Å—Å—ã–ª–∫–∞", callback_data="admin:broadcast")],
        ]
    )

    text = "–ú–µ–Ω—é –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞:"
    if isinstance(event, types.CallbackQuery):
        await event.message.edit_text(text, reply_markup=keyboard)
        await event.answer()
    else:
        await event.answer(text, reply_markup=keyboard)


def is_admin(user_id: int) -> bool:
    return user_id in ADMIN_IDS


def admin_only(handler):
    async def wrapper(event: types.Message | types.CallbackQuery, *args, **kwargs):
        user_id = event.from_user.id
        if not is_admin(user_id):
            if isinstance(event, types.Message):
                await event.answer("–≠—Ç–∞ –∫–æ–º–∞–Ω–¥–∞ –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞–º.")
            else:
                await event.answer("–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤.")
            return
        return await handler(event, *args, **kwargs)

    return wrapper


def is_cancel_text(text: Optional[str]) -> bool:
    return text is not None and text.strip().lower() in {"–æ—Ç–º–µ–Ω–∞", "cancel", "/cancel"}


def is_skip_text(text: Optional[str]) -> bool:
    return text is not None and text.strip().lower() in {"–ø—Ä–æ–ø—É—Å—Ç–∏—Ç—å", "skip", "–Ω–µ—Ç"}


def magnet_type_keyboard(prefix: str) -> InlineKeyboardMarkup:
    buttons = [
        [InlineKeyboardButton(text=label, callback_data=f"{prefix}:{key}")]
        for key, label in MAGNET_TYPES.items()
    ]
    buttons.append([InlineKeyboardButton(text="üîù –í –º–µ–Ω—é", callback_data="admin:menu")])
    return InlineKeyboardMarkup(inline_keyboard=buttons)


def broadcast_type_keyboard() -> InlineKeyboardMarkup:
    buttons = [
        [InlineKeyboardButton(text=label, callback_data=f"admin:broadcast:type:{key}")]
        for key, label in BROADCAST_TYPES.items()
    ]
    buttons.append([InlineKeyboardButton(text="üîù –í –º–µ–Ω—é", callback_data="admin:menu")])
    return InlineKeyboardMarkup(inline_keyboard=buttons)


def build_channel_list_keyboard(action: str, include_inactive: bool = False) -> InlineKeyboardMarkup:
    channels = fetch_channels(active_only=not include_inactive)
    if not channels:
        return InlineKeyboardMarkup(
            inline_keyboard=[[InlineKeyboardButton(text="üîù –í –º–µ–Ω—é", callback_data="admin:menu")]]
        )

    inline_keyboard = []
    for channel in channels:
        label = channel["title"]
        if not channel["is_active"]:
            label += " (–æ—Ç–∫–ª—é—á–µ–Ω)"
        inline_keyboard.append(
            [
                InlineKeyboardButton(
                    text=label,
                    callback_data=f"{action}:{channel['id']}",
                )
            ]
        )
    inline_keyboard.append([InlineKeyboardButton(text="üîù –í –º–µ–Ω—é", callback_data="admin:menu")])
    return InlineKeyboardMarkup(inline_keyboard=inline_keyboard)


def parse_chat_reference(value: str) -> Tuple[Optional[str | int], Optional[str]]:
    """–ü—ã—Ç–∞–µ—Ç—Å—è –≤—ã–¥–µ–ª–∏—Ç—å –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä —á–∞—Ç–∞ –∏ —Å—Å—ã–ª–∫—É –∏–∑ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–æ–≥–æ –≤–≤–æ–¥–∞."""
    text = value.strip()
    invite_link: Optional[str] = None

    if text.startswith("@"):
        chat_identifier: Optional[str | int] = text
        invite_link = f"https://t.me/{text[1:]}"
        return chat_identifier, invite_link

    if text.startswith("http://") or text.startswith("https://"):
        invite_link = text
        slug = text.rstrip("/").split("/")[-1]
        slug = slug.split("?")[0]
        if slug.startswith("+") or not slug:
            # –î–ª—è –ø—Ä–∏–≤–∞—Ç–Ω—ã—Ö —Å—Å—ã–ª–æ–∫ —Ç—Ä–µ–±—É–µ—Ç—Å—è —è–≤–Ω—ã–π ID
            return None, invite_link
        chat_identifier = f"@{slug}"
        return chat_identifier, invite_link

    try:
        chat_identifier = int(text)
        return chat_identifier, invite_link
    except ValueError:
        return None, invite_link


def extract_magnet_payload(message: types.Message, magnet_type: str) -> Tuple[Optional[str], Optional[str], Optional[str]]:
    """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç (payload, caption, error_message) –¥–ª—è –∑–∞–¥–∞–Ω–Ω–æ–≥–æ —Ç–∏–ø–∞ –ª–∏—Ç–º–∞–≥–Ω–∏—Ç–∞."""
    if magnet_type == "document":
        if message.document:
            return message.document.file_id, message.caption, None
        return None, None, "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ—Ç–ø—Ä–∞–≤—å—Ç–µ –¥–æ–∫—É–º–µ–Ω—Ç."
    if magnet_type == "photo":
        if message.photo:
            return message.photo[-1].file_id, message.caption, None
        return None, None, "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ—Ç–ø—Ä–∞–≤—å—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ."
    if magnet_type == "video":
        if message.video:
            return message.video.file_id, message.caption, None
        return None, None, "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ—Ç–ø—Ä–∞–≤—å—Ç–µ –≤–∏–¥–µ–æ."
    if magnet_type == "link":
        if message.text:
            return message.text.strip(), None, None
        return None, None, "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ—Ç–ø—Ä–∞–≤—å—Ç–µ —Å—Å—ã–ª–∫—É —Ç–µ–∫—Å—Ç–æ–º."
    if magnet_type == "text":
        if message.text:
            return message.text, None, None
        return None, None, "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ—Ç–ø—Ä–∞–≤—å—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ."
    return None, None, "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Ç–∏–ø –ª–∏—Ç–º–∞–≥–Ω–∏—Ç–∞. –ù–∞—á–Ω–∏—Ç–µ –∑–∞–Ω–æ–≤–æ."


@dp.message(Command("admin"))
@admin_only
async def handle_admin_command(message: types.Message, **_):
    await send_admin_menu(message)


@dp.callback_query(F.data == "admin:menu")
@admin_only
async def handle_admin_menu_callback(call: types.CallbackQuery, state: FSMContext, **_):
    await state.clear()
    await send_admin_menu(call)


@dp.callback_query(F.data == "admin:add")
@admin_only
async def start_add_channel(call: types.CallbackQuery, state: FSMContext, **_):
    await state.clear()
    await call.answer()
    await call.message.answer(
        "–®–∞–≥ 1/3. –û—Ç–ø—Ä–∞–≤—å—Ç–µ ID –∏–ª–∏ @username –∫–∞–Ω–∞–ª–∞, –∫–æ—Ç–æ—Ä—ã–π –Ω—É–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å.\n"
        "–ú–æ–∂–Ω–æ —Ç–∞–∫–∂–µ –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –ø—Ä—è–º—É—é —Å—Å—ã–ª–∫—É, –Ω–æ –¥–ª—è –ø—Ä–∏–≤–∞—Ç–Ω—ã—Ö —Å—Å—ã–ª–æ–∫ –ø–æ—Ç—Ä–µ–±—É–µ—Ç—Å—è —á–∏—Å–ª–æ–≤–æ–π ID.\n"
        "–ù–∞–ø–∏—à–∏—Ç–µ '–û—Ç–º–µ–Ω–∞' –¥–ª—è –≤—ã—Ö–æ–¥–∞."
    )
    await state.set_state(AddChannelStates.waiting_for_chat_identifier)


@dp.message(AddChannelStates.waiting_for_chat_identifier)
async def process_add_chat_identifier(message: types.Message, state: FSMContext):
    if not is_admin(message.from_user.id):
        await message.answer("–≠—Ç–∞ –∫–æ–º–∞–Ω–¥–∞ –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞–º.")
        await state.clear()
        return

    if not message.text:
        await message.answer("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ—Ç–ø—Ä–∞–≤—å—Ç–µ —Ç–µ–∫—Å—Ç —Å ID –∏–ª–∏ —Å—Å—ã–ª–∫–æ–π –Ω–∞ –∫–∞–Ω–∞–ª.")
        return

    if is_cancel_text(message.text):
        await message.answer("–î–æ–±–∞–≤–ª–µ–Ω–∏–µ –∫–∞–Ω–∞–ª–∞ –æ—Ç–º–µ–Ω–µ–Ω–æ.")
        await state.clear()
        await send_admin_menu(message)
        return

    chat_identifier, invite_link = parse_chat_reference(message.text)
    if chat_identifier is None:
        await message.answer(
            "–ù–µ —É–¥–∞–ª–æ—Å—å –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å –∫–∞–Ω–∞–ª. –û—Ç–ø—Ä–∞–≤—å—Ç–µ username –≤ —Ñ–æ—Ä–º–∞—Ç–µ @channel –∏–ª–∏ —á–∏—Å–ª–æ–≤–æ–π ID.\n"
            "–ï—Å–ª–∏ —É –≤–∞—Å —Ç–æ–ª—å–∫–æ –ø—Ä–∏–≤–∞—Ç–Ω–∞—è —Å—Å—ã–ª–∫–∞-–ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ, —Å–Ω–∞—á–∞–ª–∞ –ø–æ–ª—É—á–∏—Ç–µ ID –∫–∞–Ω–∞–ª–∞ –∏ –ø–æ–≤—Ç–æ—Ä–∏—Ç–µ –ø–æ–ø—ã—Ç–∫—É."
        )
        return

    try:
        chat = await bot.get_chat(chat_identifier)
    except TelegramBadRequest:
        await message.answer(
            "–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –∫–∞–Ω–∞–ª–µ. –£–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ –±–æ—Ç –¥–æ–±–∞–≤–ª–µ–Ω –≤ –∫–∞–Ω–∞–ª –∫–∞–∫ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä "
            "–∏ —á—Ç–æ —É–∫–∞–∑–∞–Ω –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π ID/username."
        )
        return

    title = getattr(chat, "title", None) or getattr(chat, "full_name", None) or chat.username or "–ë–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è"
    if not invite_link:
        username = getattr(chat, "username", None)
        if username:
            invite_link = f"https://t.me/{username}"
        elif message.text.startswith("http://") or message.text.startswith("https://"):
            invite_link = message.text.strip()

    await state.update_data(
        chat_identifier=str(chat_identifier),
        channel_title=title,
        invite_link=invite_link,
    )

    if invite_link:
        await message.answer(
            f"–ë—É–¥–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∞ —Å—Å—ã–ª–∫–∞ –¥–ª—è –∫–Ω–æ–ø–∫–∏:\n{invite_link}\n"
            "–ï—Å–ª–∏ –Ω—É–∂–Ω–æ —É–∫–∞–∑–∞—Ç—å –¥—Ä—É–≥—É—é, –æ—Ç–ø—Ä–∞–≤—å—Ç–µ –Ω–æ–≤—É—é —Å—Å—ã–ª–∫—É. –î–ª—è –ø—Ä–æ–ø—É—Å–∫–∞ –Ω–∞–ø–∏—à–∏—Ç–µ '–ø—Ä–æ–ø—É—Å—Ç–∏—Ç—å'."
        )
    else:
        await message.answer(
            "–û—Ç–ø—Ä–∞–≤—å—Ç–µ —Å—Å—ã–ª–∫—É, –∫–æ—Ç–æ—Ä—É—é –±—É–¥–µ–º –ø–æ–∫–∞–∑—ã–≤–∞—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º (–Ω–∞–ø—Ä–∏–º–µ—Ä, –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ) "
            "–∏–ª–∏ –Ω–∞–ø–∏—à–∏—Ç–µ '–ø—Ä–æ–ø—É—Å—Ç–∏—Ç—å', —á—Ç–æ–±—ã –æ—Å—Ç–∞–≤–∏—Ç—å –ø–æ–ª–µ –ø—É—Å—Ç—ã–º."
        )

    await state.set_state(AddChannelStates.waiting_for_invite_link)


@dp.message(AddChannelStates.waiting_for_invite_link)
async def process_add_invite_link(message: types.Message, state: FSMContext):
    if not is_admin(message.from_user.id):
        await message.answer("–≠—Ç–∞ –∫–æ–º–∞–Ω–¥–∞ –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞–º.")
        await state.clear()
        return

    if not message.text:
        await message.answer("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ—Ç–ø—Ä–∞–≤—å—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤—É—é —Å—Å—ã–ª–∫—É –∏–ª–∏ –Ω–∞–ø–∏—à–∏—Ç–µ '–ø—Ä–æ–ø—É—Å—Ç–∏—Ç—å'.")
        return

    if is_cancel_text(message.text):
        await message.answer("–î–æ–±–∞–≤–ª–µ–Ω–∏–µ –∫–∞–Ω–∞–ª–∞ –æ—Ç–º–µ–Ω–µ–Ω–æ.")
        await state.clear()
        await send_admin_menu(message)
        return

    data = await state.get_data()
    current_link = data.get("invite_link")

    if is_skip_text(message.text):
        invite_link = current_link
    else:
        link = message.text.strip()
        if not (link.startswith("http://") or link.startswith("https://")):
            await message.answer("–°—Å—ã–ª–∫–∞ –¥–æ–ª–∂–Ω–∞ –Ω–∞—á–∏–Ω–∞—Ç—å—Å—è —Å http:// –∏–ª–∏ https://. –ü–æ–≤—Ç–æ—Ä–∏—Ç–µ –≤–≤–æ–¥.")
            return
        invite_link = link

    await state.update_data(invite_link=invite_link)
    await message.answer(
        "–®–∞–≥ 2/3. –í—ã–±–µ—Ä–∏—Ç–µ —Ç–∏–ø –ª–∏—Ç–º–∞–≥–Ω–∏—Ç–∞ –¥–ª—è —ç—Ç–æ–≥–æ –∫–∞–Ω–∞–ª–∞:",
        reply_markup=magnet_type_keyboard("admin:add:type"),
    )
    await state.set_state(AddChannelStates.waiting_for_magnet_type)


@dp.callback_query(AddChannelStates.waiting_for_magnet_type, F.data.startswith("admin:add:type:"))
@admin_only
async def process_add_magnet_type(call: types.CallbackQuery, state: FSMContext, **_):
    _, _, _, magnet_type = call.data.split(":")
    if magnet_type not in MAGNET_TYPES:
        await call.answer("–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Ç–∏–ø.", show_alert=True)
        return

    await state.update_data(magnet_type=magnet_type)
    await call.answer()

    if magnet_type == "document":
        prompt = (
            "–®–∞–≥ 3/3. –û—Ç–ø—Ä–∞–≤—å—Ç–µ —Ñ–∞–π–ª (–¥–æ–∫—É–º–µ–Ω—Ç). –ú–æ–∂–Ω–æ —Å—Ä–∞–∑—É –¥–æ–±–∞–≤–∏—Ç—å –ø–æ–¥–ø–∏—Å—å ‚Äî –æ–Ω–∞ —Å—Ç–∞–Ω–µ—Ç –æ–ø–∏—Å–∞–Ω–∏–µ–º –ª–∏—Ç–º–∞–≥–Ω–∏—Ç–∞."
        )
    elif magnet_type == "photo":
        prompt = (
            "–®–∞–≥ 3/3. –û—Ç–ø—Ä–∞–≤—å—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ. –ú–æ–∂–Ω–æ —Å—Ä–∞–∑—É –¥–æ–±–∞–≤–∏—Ç—å –ø–æ–¥–ø–∏—Å—å ‚Äî –æ–Ω–∞ —Å—Ç–∞–Ω–µ—Ç –æ–ø–∏—Å–∞–Ω–∏–µ–º –ª–∏—Ç–º–∞–≥–Ω–∏—Ç–∞."
        )
    elif magnet_type == "link":
        prompt = "–®–∞–≥ 3/3. –û—Ç–ø—Ä–∞–≤—å—Ç–µ —Å—Å—ã–ª–∫—É, –∫–æ—Ç–æ—Ä—É—é –ø–æ–ª—É—á–∞—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏."
    else:
        prompt = "–®–∞–≥ 3/3. –û—Ç–ø—Ä–∞–≤—å—Ç–µ —Ç–µ–∫—Å—Ç –ª–∏—Ç–º–∞–≥–Ω–∏—Ç–∞."

    await call.message.answer(prompt + "\n–ù–∞–ø–∏—à–∏—Ç–µ '–û—Ç–º–µ–Ω–∞' –¥–ª—è –≤—ã—Ö–æ–¥–∞.")
    await state.set_state(AddChannelStates.waiting_for_magnet_payload)


@dp.message(AddChannelStates.waiting_for_magnet_payload)
async def process_add_magnet_payload(message: types.Message, state: FSMContext):
    if not is_admin(message.from_user.id):
        await message.answer("–≠—Ç–∞ –∫–æ–º–∞–Ω–¥–∞ –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞–º.")
        await state.clear()
        return

    cancel_candidate = message.text or message.caption
    if is_cancel_text(cancel_candidate):
        await message.answer("–î–æ–±–∞–≤–ª–µ–Ω–∏–µ –∫–∞–Ω–∞–ª–∞ –æ—Ç–º–µ–Ω–µ–Ω–æ.")
        await state.clear()
        await send_admin_menu(message)
        return

    data = await state.get_data()
    magnet_type = data.get("magnet_type")
    if not magnet_type:
        await message.answer("–¢–∏–ø –ª–∏—Ç–º–∞–≥–Ω–∏—Ç–∞ –Ω–µ –≤—ã–±—Ä–∞–Ω. –ù–∞—á–Ω–∏—Ç–µ –ø—Ä–æ—Ü–µ—Å—Å –∑–∞–Ω–æ–≤–æ.")
        await state.clear()
        await send_admin_menu(message)
        return

    magnet_payload, caption, error = extract_magnet_payload(message, magnet_type)
    if error:
        await message.answer(error)
        if error.startswith("–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π"):
            await state.clear()
            await send_admin_menu(message)
        return

    await state.update_data(magnet_payload=magnet_payload)

    needs_caption = magnet_type in {"document", "photo", "link"}

    if caption:
        await state.update_data(magnet_caption=caption)
        await finalize_channel_creation(message, state)
    elif needs_caption:
        await message.answer(
            "–û—Ç–ø—Ä–∞–≤—å—Ç–µ —Ç–µ–∫—Å—Ç, –∫–æ—Ç–æ—Ä—ã–π –ø—Ä–∏–∫—Ä–µ–ø–∏–º –∫ –ª–∏—Ç–º–∞–≥–Ω–∏—Ç—É, –∏–ª–∏ –Ω–∞–ø–∏—à–∏—Ç–µ '–ø—Ä–æ–ø—É—Å—Ç–∏—Ç—å', –µ—Å–ª–∏ –æ–Ω –Ω–µ –Ω—É–∂–µ–Ω."
        )
        await state.set_state(AddChannelStates.waiting_for_caption)
    else:
        await state.update_data(magnet_caption=None)
        await finalize_channel_creation(message, state)


@dp.message(AddChannelStates.waiting_for_caption)
async def process_add_caption(message: types.Message, state: FSMContext):
    if not is_admin(message.from_user.id):
        await message.answer("–≠—Ç–∞ –∫–æ–º–∞–Ω–¥–∞ –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞–º.")
        await state.clear()
        return

    if not message.text:
        await message.answer("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ—Ç–ø—Ä–∞–≤—å—Ç–µ —Ç–µ–∫—Å—Ç –∏–ª–∏ –Ω–∞–ø–∏—à–∏—Ç–µ '–ø—Ä–æ–ø—É—Å—Ç–∏—Ç—å'.")
        return

    if is_cancel_text(message.text):
        await message.answer("–î–æ–±–∞–≤–ª–µ–Ω–∏–µ –∫–∞–Ω–∞–ª–∞ –æ—Ç–º–µ–Ω–µ–Ω–æ.")
        await state.clear()
        await send_admin_menu(message)
        return

    caption = None if is_skip_text(message.text) else message.text
    await state.update_data(magnet_caption=caption)
    await finalize_channel_creation(message, state)
def magnet_type_label(value: str) -> str:
    return MAGNET_TYPES.get(value, value)


def build_link_keyboard(text: Optional[str], url: Optional[str]) -> Optional[InlineKeyboardMarkup]:
    if text and url:
        return InlineKeyboardMarkup(inline_keyboard=[[InlineKeyboardButton(text=text, url=url)]])
    return None


def shorten_text(value: str, limit: int = 120) -> str:
    return value if len(value) <= limit else value[: limit - 1] + "‚Ä¶"


async def finalize_channel_creation(message: types.Message, state: FSMContext):
    data = await state.get_data()
    channel_title = data.get("channel_title", "–ë–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è")
    chat_identifier = data.get("chat_identifier")
    invite_link = data.get("invite_link")
    magnet_type = data.get("magnet_type")
    magnet_payload = data.get("magnet_payload")
    magnet_caption = data.get("magnet_caption")

    if not all([channel_title, chat_identifier, magnet_type, magnet_payload]):
        await message.answer("–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –∫–∞–Ω–∞–ª ‚Äî –¥–∞–Ω–Ω—ã–µ –∑–∞–ø–æ–ª–Ω–µ–Ω—ã –Ω–µ –ø–æ–ª–Ω–æ—Å—Ç—å—é. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.")
        return

    channel_id = add_channel(
        title=channel_title,
        chat_identifier=str(chat_identifier),
        invite_link=invite_link,
        magnet_type=magnet_type,
        magnet_payload=magnet_payload,
        magnet_caption=magnet_caption,
    )

    await state.clear()
    summary_lines = [
        f"–ö–∞–Ω–∞–ª ¬´{channel_title}¬ª —É—Å–ø–µ—à–Ω–æ –¥–æ–±–∞–≤–ª–µ–Ω (ID –∑–∞–ø–∏—Å–∏: {channel_id}).",
        f"–¢–∏–ø –ª–∏—Ç–º–∞–≥–Ω–∏—Ç–∞: {magnet_type_label(magnet_type)}",
    ]
    if invite_link:
        summary_lines.append(f"–°—Å—ã–ª–∫–∞ –¥–ª—è –∫–Ω–æ–ø–∫–∏: {invite_link}")

    await message.answer("\n".join(summary_lines))
    await send_admin_menu(message)


@dp.callback_query(F.data == "admin:list")
@admin_only
async def handle_admin_list(call: types.CallbackQuery, state: FSMContext, **_):
    channels = fetch_channels(active_only=False)
    await call.answer()

    if not channels:
        await call.message.answer("–ö–∞–Ω–∞–ª—ã –µ—â—ë –Ω–µ –¥–æ–±–∞–≤–ª–µ–Ω—ã.")
        return

    lines = []
    for channel in channels:
        status = "‚úÖ –ê–∫—Ç–∏–≤–µ–Ω" if channel["is_active"] else "üö´ –û—Ç–∫–ª—é—á–µ–Ω"
        lines.append(f"{channel['id']}. {channel['title']} ‚Äî {status}")
        lines.append(f"   –ò–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä: {channel['chat_identifier']}")
        lines.append(f"   –¢–∏–ø: {magnet_type_label(channel['magnet_type'])}")
        if channel["invite_link"]:
            lines.append(f"   –°—Å—ã–ª–∫–∞: {channel['invite_link']}")
        if channel["magnet_caption"]:
            lines.append(f"   –û–ø–∏—Å–∞–Ω–∏–µ: {shorten_text(channel['magnet_caption'])}")
        lines.append("")

    await call.message.answer("\n".join(lines).strip())


@dp.callback_query(F.data == "admin:edit")
@admin_only
async def start_edit_magnet(call: types.CallbackQuery, state: FSMContext, **_):
    await state.clear()
    channels = fetch_channels()
    await call.answer()

    if not channels:
        await call.message.answer("–ê–∫—Ç–∏–≤–Ω—ã—Ö –∫–∞–Ω–∞–ª–æ–≤ –Ω–µ—Ç. –°–Ω–∞—á–∞–ª–∞ –¥–æ–±–∞–≤—å—Ç–µ –∫–∞–Ω–∞–ª.")
        return

    await call.message.answer(
        "–í—ã–±–µ—Ä–∏—Ç–µ –∫–∞–Ω–∞–ª, –¥–ª—è –∫–æ—Ç–æ—Ä–æ–≥–æ –Ω—É–∂–Ω–æ –∏–∑–º–µ–Ω–∏—Ç—å –ª–∏—Ç–º–∞–≥–Ω–∏—Ç:",
        reply_markup=build_channel_list_keyboard("admin:edit"),
    )
    await state.set_state(EditMagnetStates.waiting_for_channel_choice)


@dp.callback_query(EditMagnetStates.waiting_for_channel_choice, F.data.startswith("admin:edit:"))
@admin_only
async def choose_channel_for_edit(call: types.CallbackQuery, state: FSMContext, **_):
    try:
        channel_id = int(call.data.split(":")[-1])
    except (ValueError, IndexError):
        await call.answer("–ù–µ —É–¥–∞–ª–æ—Å—å –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å –∫–∞–Ω–∞–ª.", show_alert=True)
        return

    channel = fetch_channel(channel_id)
    if not channel:
        await call.answer("–ö–∞–Ω–∞–ª –Ω–µ –Ω–∞–π–¥–µ–Ω.", show_alert=True)
        return

    await state.update_data(
        channel_id=channel_id,
        channel_title=channel["title"],
    )
    await call.answer()
    await call.message.answer(
        f"–ò–∑–º–µ–Ω—è–µ–º –ª–∏—Ç–º–∞–≥–Ω–∏—Ç –¥–ª—è ¬´{channel['title']}¬ª.\n"
        f"–¢–µ–∫—É—â–∏–π —Ç–∏–ø: {magnet_type_label(channel['magnet_type'])}.",
        reply_markup=magnet_type_keyboard("admin:edit:type"),
    )
    await state.set_state(EditMagnetStates.waiting_for_magnet_type)


@dp.callback_query(EditMagnetStates.waiting_for_magnet_type, F.data.startswith("admin:edit:type:"))
@admin_only
async def process_edit_magnet_type(call: types.CallbackQuery, state: FSMContext, **_):
    try:
        magnet_type = call.data.split(":")[-1]
    except IndexError:
        await call.answer("–ù–µ —É–¥–∞–ª–æ—Å—å —Ä–∞—Å–ø–æ–∑–Ω–∞—Ç—å —Ç–∏–ø.", show_alert=True)
        return

    if magnet_type not in MAGNET_TYPES:
        await call.answer("–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Ç–∏–ø.", show_alert=True)
        return

    await state.update_data(magnet_type=magnet_type)
    await call.answer()

    if magnet_type == "document":
        prompt = "–û—Ç–ø—Ä–∞–≤—å—Ç–µ –Ω–æ–≤—ã–π —Ñ–∞–π–ª-–¥–æ–∫—É–º–µ–Ω—Ç. –ü–æ–¥–ø–∏—Å—å –ø—Ä–∏ –∂–µ–ª–∞–Ω–∏–∏ —Å—Ç–∞–Ω–µ—Ç –æ–ø–∏—Å–∞–Ω–∏–µ–º."
    elif magnet_type == "photo":
        prompt = "–û—Ç–ø—Ä–∞–≤—å—Ç–µ –Ω–æ–≤–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ. –ü–æ–¥–ø–∏—Å—å –ø—Ä–∏ –∂–µ–ª–∞–Ω–∏–∏ —Å—Ç–∞–Ω–µ—Ç –æ–ø–∏—Å–∞–Ω–∏–µ–º."
    elif magnet_type == "link":
        prompt = "–û—Ç–ø—Ä–∞–≤—å—Ç–µ –Ω–æ–≤—É—é —Å—Å—ã–ª–∫—É –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π."
    else:
        prompt = "–û—Ç–ø—Ä–∞–≤—å—Ç–µ –Ω–æ–≤—ã–π —Ç–µ–∫—Å—Ç –ª–∏—Ç–º–∞–≥–Ω–∏—Ç–∞."

    await call.message.answer(prompt + "\n–ù–∞–ø–∏—à–∏—Ç–µ '–û—Ç–º–µ–Ω–∞' –¥–ª—è –æ—Ç–º–µ–Ω—ã.")
    await state.set_state(EditMagnetStates.waiting_for_magnet_payload)


@dp.message(EditMagnetStates.waiting_for_magnet_payload)
async def process_edit_magnet_payload(message: types.Message, state: FSMContext):
    if not is_admin(message.from_user.id):
        await message.answer("–≠—Ç–∞ –∫–æ–º–∞–Ω–¥–∞ –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞–º.")
        await state.clear()
        return

    cancel_candidate = message.text or message.caption
    if is_cancel_text(cancel_candidate):
        await message.answer("–ò–∑–º–µ–Ω–µ–Ω–∏–µ –ª–∏—Ç–º–∞–≥–Ω–∏—Ç–∞ –æ—Ç–º–µ–Ω–µ–Ω–æ.")
        await state.clear()
        await send_admin_menu(message)
        return

    data = await state.get_data()
    magnet_type = data.get("magnet_type")
    if not magnet_type:
        await message.answer("–ù–µ –≤—ã–±—Ä–∞–Ω —Ç–∏–ø –ª–∏—Ç–º–∞–≥–Ω–∏—Ç–∞. –ù–∞—á–Ω–∏—Ç–µ –∑–∞–Ω–æ–≤–æ.")
        await state.clear()
        await send_admin_menu(message)
        return

    magnet_payload, caption, error = extract_magnet_payload(message, magnet_type)
    if error:
        await message.answer(error)
        if error.startswith("–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π"):
            await state.clear()
            await send_admin_menu(message)
        return

    await state.update_data(magnet_payload=magnet_payload)
    needs_caption = magnet_type in {"document", "photo", "link"}

    if caption:
        await state.update_data(magnet_caption=caption)
        await finalize_magnet_update(message, state)
    elif needs_caption:
        await message.answer(
            "–û—Ç–ø—Ä–∞–≤—å—Ç–µ —Ç–µ–∫—Å—Ç-–æ–ø–∏—Å–∞–Ω–∏–µ –¥–ª—è –ª–∏—Ç–º–∞–≥–Ω–∏—Ç–∞ –∏–ª–∏ –Ω–∞–ø–∏—à–∏—Ç–µ '–ø—Ä–æ–ø—É—Å—Ç–∏—Ç—å', —á—Ç–æ–±—ã –æ—Å—Ç–∞–≤–∏—Ç—å –ø–æ–ª–µ –ø—É—Å—Ç—ã–º."
        )
        await state.set_state(EditMagnetStates.waiting_for_caption)
    else:
        await state.update_data(magnet_caption=None)
        await finalize_magnet_update(message, state)


@dp.message(EditMagnetStates.waiting_for_caption)
async def process_edit_caption(message: types.Message, state: FSMContext):
    if not is_admin(message.from_user.id):
        await message.answer("–≠—Ç–∞ –∫–æ–º–∞–Ω–¥–∞ –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞–º.")
        await state.clear()
        return

    if not message.text:
        await message.answer("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ—Ç–ø—Ä–∞–≤—å—Ç–µ —Ç–µ–∫—Å—Ç –∏–ª–∏ –Ω–∞–ø–∏—à–∏—Ç–µ '–ø—Ä–æ–ø—É—Å—Ç–∏—Ç—å'.")
        return

    if is_cancel_text(message.text):
        await message.answer("–ò–∑–º–µ–Ω–µ–Ω–∏–µ –ª–∏—Ç–º–∞–≥–Ω–∏—Ç–∞ –æ—Ç–º–µ–Ω–µ–Ω–æ.")
        await state.clear()
        await send_admin_menu(message)
        return

    caption = None if is_skip_text(message.text) else message.text
    await state.update_data(magnet_caption=caption)
    await finalize_magnet_update(message, state)


async def finalize_magnet_update(message: types.Message, state: FSMContext):
    data = await state.get_data()
    channel_id = data.get("channel_id")
    channel_title = data.get("channel_title", "–Ω–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π –∫–∞–Ω–∞–ª")
    magnet_type = data.get("magnet_type")
    magnet_payload = data.get("magnet_payload")
    magnet_caption = data.get("magnet_caption")

    if not channel_id or not magnet_type or not magnet_payload:
        await message.answer("–ù–µ —É–¥–∞–ª–æ—Å—å –æ–±–Ω–æ–≤–∏—Ç—å –ª–∏—Ç–º–∞–≥–Ω–∏—Ç ‚Äî –Ω–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –¥–∞–Ω–Ω—ã—Ö. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.")
        await state.clear()
        await send_admin_menu(message)
        return

    updated = update_channel(
        channel_id,
        magnet_type=magnet_type,
        magnet_payload=magnet_payload,
        magnet_caption=magnet_caption,
    )

    await state.clear()
    if updated:
        await message.answer(
            f"–õ–∏—Ç–º–∞–≥–Ω–∏—Ç –¥–ª—è ¬´{channel_title}¬ª –æ–±–Ω–æ–≤–ª—ë–Ω.\n–¢–∏–ø: {magnet_type_label(magnet_type)}."
        )
    else:
        await message.answer("–ù–µ —É–¥–∞–ª–æ—Å—å –æ–±–Ω–æ–≤–∏—Ç—å –∑–∞–ø–∏—Å—å. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –¥–∞–Ω–Ω—ã–µ –∏ –ø–æ–≤—Ç–æ—Ä–∏—Ç–µ –ø–æ–ø—ã—Ç–∫—É.")

    await send_admin_menu(message)


@dp.callback_query(F.data == "admin:delete")
@admin_only
async def start_delete_channel(call: types.CallbackQuery, state: FSMContext, **_):
    await state.clear()
    channels = fetch_channels()
    await call.answer()

    if not channels:
        await call.message.answer("–ê–∫—Ç–∏–≤–Ω—ã—Ö –∫–∞–Ω–∞–ª–æ–≤ –Ω–µ—Ç.")
        return

    await call.message.answer(
        "–í—ã–±–µ—Ä–∏—Ç–µ –∫–∞–Ω–∞–ª, –∫–æ—Ç–æ—Ä—ã–π –Ω—É–∂–Ω–æ –æ—Ç–∫–ª—é—á–∏—Ç—å:",
        reply_markup=build_channel_list_keyboard("admin:delete"),
    )
    await state.set_state(DeleteChannelStates.waiting_for_channel_choice)


@dp.callback_query(DeleteChannelStates.waiting_for_channel_choice, F.data.startswith("admin:delete:"))
@admin_only
async def confirm_delete_channel(call: types.CallbackQuery, state: FSMContext, **_):
    try:
        channel_id = int(call.data.split(":")[-1])
    except (ValueError, IndexError):
        await call.answer("–ù–µ —É–¥–∞–ª–æ—Å—å –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å –∫–∞–Ω–∞–ª.", show_alert=True)
        return

    channel = fetch_channel(channel_id)
    if not channel:
        await call.answer("–ö–∞–Ω–∞–ª –Ω–µ –Ω–∞–π–¥–µ–Ω.", show_alert=True)
        return

    await state.update_data(channel_id=channel_id, channel_title=channel["title"])
    await call.answer()
    keyboard = InlineKeyboardMarkup(
        inline_keyboard=[
            [
                InlineKeyboardButton(
                    text="‚úÖ –î–∞, –æ—Ç–∫–ª—é—á–∏—Ç—å",
                    callback_data=f"admin:delete:confirm:{channel_id}",
                )
            ],
            [InlineKeyboardButton(text="‚Ü©Ô∏è –û—Ç–º–µ–Ω–∞", callback_data="admin:menu")],
        ]
    )
    await call.message.answer(
        f"–í—ã —É–≤–µ—Ä–µ–Ω—ã, —á—Ç–æ —Ö–æ—Ç–∏—Ç–µ –æ—Ç–∫–ª—é—á–∏—Ç—å –∫–∞–Ω–∞–ª ¬´{channel['title']}¬ª?\n"
        "–ï–≥–æ –∫–Ω–æ–ø–∫–∞ –∏—Å—á–µ–∑–Ω–µ—Ç –∏–∑ –º–µ–Ω—é –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π, –Ω–æ –¥–∞–Ω–Ω—ã–µ –º–æ–∂–Ω–æ –±—É–¥–µ—Ç –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –≤—Ä—É—á–Ω—É—é.",
        reply_markup=keyboard,
    )
    await state.set_state(DeleteChannelStates.waiting_for_confirmation)


@dp.callback_query(DeleteChannelStates.waiting_for_confirmation, F.data.startswith("admin:delete:confirm:"))
@admin_only
async def complete_delete_channel(call: types.CallbackQuery, state: FSMContext, **_):
    data = await state.get_data()
    stored_id = data.get("channel_id")
    try:
        channel_id = int(call.data.split(":")[-1])
    except (ValueError, IndexError):
        await call.answer("–ù–µ —É–¥–∞–ª–æ—Å—å –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å –∫–∞–Ω–∞–ª.", show_alert=True)
        return

    if stored_id and stored_id != channel_id:
        await call.answer("–ö–∞–Ω–∞–ª –Ω–µ —Å–æ–≤–ø–∞–¥–∞–µ—Ç —Å –≤—ã–±—Ä–∞–Ω–Ω—ã–º —Ä–∞–Ω–µ–µ. –ü–æ–≤—Ç–æ—Ä–∏—Ç–µ –ø—Ä–æ—Ü–µ–¥—É—Ä—É.", show_alert=True)
        await state.clear()
        await send_admin_menu(call)
        return

    channel = fetch_channel(channel_id)
    if not channel:
        await call.answer("–ö–∞–Ω–∞–ª –Ω–µ –Ω–∞–π–¥–µ–Ω.", show_alert=True)
        await state.clear()
        await send_admin_menu(call)
        return

    await call.answer()
    await state.clear()

    if set_channel_active(channel_id, False):
        await call.message.answer(f"–ö–∞–Ω–∞–ª ¬´{channel['title']}¬ª –æ—Ç–∫–ª—é—á—ë–Ω –∏ –∏—Å—á–µ–∑–Ω–µ—Ç –∏–∑ –º–µ–Ω—é –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π.")
    else:
        await call.message.answer("–ù–µ —É–¥–∞–ª–æ—Å—å –æ–±–Ω–æ–≤–∏—Ç—å —Å—Ç–∞—Ç—É—Å –∫–∞–Ω–∞–ª–∞. –ü–æ–≤—Ç–æ—Ä–∏—Ç–µ –ø–æ–ø—ã—Ç–∫—É.")

    await send_admin_menu(call)


@dp.callback_query(F.data == "admin:stats")
@admin_only
async def handle_admin_stats(call: types.CallbackQuery, state: FSMContext, **_):
    await call.answer()
    total_users = get_user_count()
    stats = get_reward_stats()

    lines = [f"–û–±—â–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π: {total_users}"]
    if stats:
        lines.append("")
        lines.append("–í—ã–¥–∞–Ω–Ω—ã–µ –ª–∏—Ç–º–∞–≥–Ω–∏—Ç—ã –ø–æ –∫–∞–Ω–∞–ª–∞–º:")
        for row in stats:
            lines.append(f"- {row['title']}: {row['delivered']}")
    else:
        lines.append("–õ–∏—Ç–º–∞–≥–Ω–∏—Ç—ã –ø–æ–∫–∞ –Ω–µ –≤—ã–¥–∞–≤–∞–ª–∏—Å—å.")

    await call.message.answer("\n".join(lines))


@dp.callback_query(F.data == "admin:broadcast")
@admin_only
async def start_broadcast(call: types.CallbackQuery, state: FSMContext, **_):
    await state.clear()
    await call.answer()
    await call.message.answer(
        "–í—ã–±–µ—Ä–∏—Ç–µ —Ç–∏–ø —Å–æ–æ–±—â–µ–Ω–∏—è –¥–ª—è —Ä–∞—Å—Å—ã–ª–∫–∏:",
        reply_markup=broadcast_type_keyboard(),
    )
    await state.set_state(BroadcastStates.waiting_for_content_type)


@dp.callback_query(BroadcastStates.waiting_for_content_type, F.data.startswith("admin:broadcast:type:"))
@admin_only
async def set_broadcast_type(call: types.CallbackQuery, state: FSMContext, **_):
    try:
        broadcast_type = call.data.split(":")[-1]
    except IndexError:
        await call.answer("–ù–µ —É–¥–∞–ª–æ—Å—å —Ä–∞—Å–ø–æ–∑–Ω–∞—Ç—å —Ç–∏–ø.", show_alert=True)
        return

    if broadcast_type not in BROADCAST_TYPES:
        await call.answer("–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Ç–∏–ø.", show_alert=True)
        return

    await state.update_data(broadcast_type=broadcast_type)
    await call.answer()

    prompts = {
        "text": "–û—Ç–ø—Ä–∞–≤—å—Ç–µ —Ç–µ–∫—Å—Ç —Å–æ–æ–±—â–µ–Ω–∏—è, –∫–æ—Ç–æ—Ä–æ–µ –ø–æ–ª—É—á–∞—Ç –≤—Å–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏.",
        "photo": "–û—Ç–ø—Ä–∞–≤—å—Ç–µ —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏—é —Å –ø–æ–¥–ø–∏—Å—å—é (–ø–æ –∂–µ–ª–∞–Ω–∏—é).",
        "video": "–û—Ç–ø—Ä–∞–≤—å—Ç–µ –≤–∏–¥–µ–æ —Å –ø–æ–¥–ø–∏—Å—å—é (–ø–æ –∂–µ–ª–∞–Ω–∏—é).",
        "document": "–û—Ç–ø—Ä–∞–≤—å—Ç–µ –¥–æ–∫—É–º–µ–Ω—Ç —Å –ø–æ–¥–ø–∏—Å—å—é (–ø–æ –∂–µ–ª–∞–Ω–∏—é).",
    }
    await call.message.answer(
        prompts.get(broadcast_type, "–û—Ç–ø—Ä–∞–≤—å—Ç–µ —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ —Å–æ–æ–±—â–µ–Ω–∏—è.") + "\n–ù–∞–ø–∏—à–∏—Ç–µ '–û—Ç–º–µ–Ω–∞' –¥–ª—è –æ—Ç–º–µ–Ω—ã.",
    )
    await state.set_state(BroadcastStates.waiting_for_content)


@dp.message(BroadcastStates.waiting_for_content)
async def process_broadcast_content(message: types.Message, state: FSMContext):
    if not is_admin(message.from_user.id):
        await message.answer("–≠—Ç–∞ –∫–æ–º–∞–Ω–¥–∞ –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞–º.")
        await state.clear()
        return

    cancel_candidate = message.text or message.caption
    if is_cancel_text(cancel_candidate):
        await message.answer("–†–∞—Å—Å—ã–ª–∫–∞ –æ—Ç–º–µ–Ω–µ–Ω–∞.")
        await state.clear()
        await send_admin_menu(message)
        return

    data = await state.get_data()
    broadcast_type = data.get("broadcast_type")
    if not broadcast_type:
        await message.answer("–¢–∏–ø —Å–æ–æ–±—â–µ–Ω–∏—è –Ω–µ –≤—ã–±—Ä–∞–Ω. –ù–∞—á–Ω–∏—Ç–µ –ø—Ä–æ—Ü–µ–¥—É—Ä—É –∑–∞–Ω–æ–≤–æ.")
        await state.clear()
        await send_admin_menu(message)
        return

    payload, caption, error = extract_magnet_payload(message, broadcast_type)
    if error:
        await message.answer(error)
        if error.startswith("–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π"):
            await state.clear()
            await send_admin_menu(message)
        return

    await state.update_data(broadcast_payload=payload, broadcast_caption=caption)
    await message.answer(
        "–•–æ—Ç–∏—Ç–µ –¥–æ–±–∞–≤–∏—Ç—å –∫–Ω–æ–ø–∫—É —Å —Å—Å—ã–ª–∫–æ–π? –û—Ç–ø—Ä–∞–≤—å—Ç–µ —Ç–µ–∫—Å—Ç –∫–Ω–æ–ø–∫–∏ –∏ —Å—Å—ã–ª–∫—É —á–µ—Ä–µ–∑ —Ä–∞–∑–¥–µ–ª–∏—Ç–µ–ª—å `|||`,\n"
        "–Ω–∞–ø—Ä–∏–º–µ—Ä: –û—Ç–∫—Ä—ã—Ç—å —Å–∞–π—Ç|||https://example.com\n"
        "–ï—Å–ª–∏ –∫–Ω–æ–ø–∫–∞ –Ω–µ –Ω—É–∂–Ω–∞, –Ω–∞–ø–∏—à–∏—Ç–µ '–ø—Ä–æ–ø—É—Å—Ç–∏—Ç—å'."
    )
    await state.set_state(BroadcastStates.waiting_for_button)


@dp.message(BroadcastStates.waiting_for_button)
async def process_broadcast_button(message: types.Message, state: FSMContext):
    if not is_admin(message.from_user.id):
        await message.answer("–≠—Ç–∞ –∫–æ–º–∞–Ω–¥–∞ –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞–º.")
        await state.clear()
        return

    if not message.text:
        await message.answer("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ—Ç–ø—Ä–∞–≤—å—Ç–µ —Ç–µ–∫—Å—Ç –∏–ª–∏ –Ω–∞–ø–∏—à–∏—Ç–µ '–ø—Ä–æ–ø—É—Å—Ç–∏—Ç—å'.")
        return

    if is_cancel_text(message.text):
        await message.answer("–†–∞—Å—Å—ã–ª–∫–∞ –æ—Ç–º–µ–Ω–µ–Ω–∞.")
        await state.clear()
        await send_admin_menu(message)
        return

    data = await state.get_data()

    if is_skip_text(message.text):
        await state.update_data(button_text=None, button_url=None)
    else:
        parts = [part.strip() for part in message.text.split("|||")]
        if len(parts) != 2 or not all(parts):
            await message.answer(
                "–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ `–¢–µ–∫—Å—Ç –∫–Ω–æ–ø–∫–∏|||https://example.com` –∏–ª–∏ –Ω–∞–ø–∏—à–∏—Ç–µ '–ø—Ä–æ–ø—É—Å—Ç–∏—Ç—å'."
            )
            return
        text_part, url_part = parts
        if not (url_part.startswith("http://") or url_part.startswith("https://")):
            await message.answer("–°—Å—ã–ª–∫–∞ –¥–æ–ª–∂–Ω–∞ –Ω–∞—á–∏–Ω–∞—Ç—å—Å—è —Å http:// –∏–ª–∏ https://.")
            return
        await state.update_data(button_text=text_part, button_url=url_part)

    await show_broadcast_preview(message, state)
    await state.set_state(BroadcastStates.waiting_for_confirmation)


async def show_broadcast_preview(message: types.Message, state: FSMContext):
    data = await state.get_data()
    broadcast_type = data.get("broadcast_type")
    payload = data.get("broadcast_payload")
    caption = data.get("broadcast_caption")
    button_text = data.get("button_text")
    button_url = data.get("button_url")

    if not broadcast_type or not payload:
        await message.answer("–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–¥–≥–æ—Ç–æ–≤–∏—Ç—å –ø—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω—ã–π –ø—Ä–æ—Å–º–æ—Ç—Ä. –†–∞—Å—Å—ã–ª–∫–∞ –æ—Ç–º–µ–Ω–µ–Ω–∞.")
        await state.clear()
        await send_admin_menu(message)
        return

    markup = build_link_keyboard(button_text, button_url)

    try:
        if broadcast_type == "text":
            await message.answer(payload, reply_markup=markup)
        elif broadcast_type == "photo":
            await message.answer_photo(payload, caption=caption, reply_markup=markup)
        elif broadcast_type == "video":
            await message.answer_video(payload, caption=caption, reply_markup=markup)
        elif broadcast_type == "document":
            await message.answer_document(payload, caption=caption, reply_markup=markup)
        else:
            await message.answer("–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Ç–∏–ø —Å–æ–æ–±—â–µ–Ω–∏—è. –†–∞—Å—Å—ã–ª–∫–∞ –æ—Ç–º–µ–Ω–µ–Ω–∞.")
            await state.clear()
            await send_admin_menu(message)
            return
    except TelegramBadRequest as exc:
        logging.error("–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –ø—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä: %s", exc)
        await message.answer("–ù–µ —É–¥–∞–ª–æ—Å—å —Å—Ñ–æ—Ä–º–∏—Ä–æ–≤–∞—Ç—å –ø—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –¥–∞–Ω–Ω—ã–µ –∏ –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.")
        return

    total_users = get_user_count()
    summary = [
        "–ü—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –≤—ã—à–µ.",
        f"–¢–∏–ø: {BROADCAST_TYPES.get(broadcast_type, broadcast_type)}",
        f"–ü–æ–ª—É—á–∞—Ç–µ–ª–µ–π: {total_users}",
    ]
    if button_text and button_url:
        summary.append(f"–ö–Ω–æ–ø–∫–∞: {button_text} ‚Üí {button_url}")

    keyboard = InlineKeyboardMarkup(
        inline_keyboard=[
            [InlineKeyboardButton(text="‚úÖ –û—Ç–ø—Ä–∞–≤–∏—Ç—å", callback_data="admin:broadcast:send")],
            [InlineKeyboardButton(text="‚Ü©Ô∏è –û—Ç–º–µ–Ω–∞", callback_data="admin:broadcast:cancel")],
        ]
    )
    await message.answer("\n".join(summary), reply_markup=keyboard)


async def dispatch_broadcast_to_user(
    user_id: int,
    broadcast_type: str,
    payload: str,
    caption: Optional[str],
    markup: Optional[InlineKeyboardMarkup],
):
    if broadcast_type == "text":
        await bot.send_message(user_id, payload, reply_markup=markup)
    elif broadcast_type == "photo":
        await bot.send_photo(user_id, payload, caption=caption, reply_markup=markup)
    elif broadcast_type == "video":
        await bot.send_video(user_id, payload, caption=caption, reply_markup=markup)
    elif broadcast_type == "document":
        await bot.send_document(user_id, payload, caption=caption, reply_markup=markup)
    else:
        raise ValueError(f"Unsupported broadcast type: {broadcast_type}")


@dp.callback_query(BroadcastStates.waiting_for_confirmation, F.data == "admin:broadcast:send")
@admin_only
async def execute_broadcast(call: types.CallbackQuery, state: FSMContext, **_):
    data = await state.get_data()
    broadcast_type = data.get("broadcast_type")
    payload = data.get("broadcast_payload")
    caption = data.get("broadcast_caption")
    button_text = data.get("button_text")
    button_url = data.get("button_url")

    if not broadcast_type or not payload:
        await call.answer("–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è —Ä–∞—Å—Å—ã–ª–∫–∏.", show_alert=True)
        await state.clear()
        await send_admin_menu(call)
        return

    markup = build_link_keyboard(button_text, button_url)
    recipients = list(get_all_user_ids())

    await call.answer("–†–∞—Å—Å—ã–ª–∫–∞ –∑–∞–ø—É—â–µ–Ω–∞.")
    status_message = await call.message.answer(f"–û—Ç–ø—Ä–∞–≤–ª—è—é —Å–æ–æ–±—â–µ–Ω–∏–µ {len(recipients)} –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º‚Ä¶")

    success = 0
    failed = 0

    for user_id in recipients:
        try:
            await dispatch_broadcast_to_user(user_id, broadcast_type, payload, caption, markup)
            success += 1
        except TelegramRetryAfter as exc:
            await asyncio.sleep(exc.retry_after + 1)
            try:
                await dispatch_broadcast_to_user(user_id, broadcast_type, payload, caption, markup)
                success += 1
            except Exception as inner_exc:
                logging.warning("–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é %s –ø–æ—Å–ª–µ –ø–∞—É–∑—ã: %s", user_id, inner_exc)
                failed += 1
        except TelegramForbiddenError:
            failed += 1
        except TelegramBadRequest as exc:
            logging.warning("–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é %s: %s", user_id, exc)
            failed += 1
        except Exception as exc:
            logging.error("–ù–µ–æ–∂–∏–¥–∞–Ω–Ω–∞—è –æ—à–∏–±–∫–∞ –ø—Ä–∏ —Ä–∞—Å—Å—ã–ª–∫–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é %s: %s", user_id, exc)
            failed += 1

        await asyncio.sleep(0.05)

    await state.clear()

    summary = (
        f"–†–∞—Å—Å—ã–ª–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞.\n"
        f"–£—Å–ø–µ—à–Ω–æ: {success}\n"
        f"–ù–µ –¥–æ—Å—Ç–∞–≤–ª–µ–Ω–æ: {failed}"
    )
    await status_message.edit_text(summary)
    await send_admin_menu(call)


@dp.callback_query(BroadcastStates.waiting_for_confirmation, F.data == "admin:broadcast:cancel")
@admin_only
async def cancel_broadcast(call: types.CallbackQuery, state: FSMContext, **_):
    await state.clear()
    await call.answer("–†–∞—Å—Å—ã–ª–∫–∞ –æ—Ç–º–µ–Ω–µ–Ω–∞.")
    await call.message.answer("–†–∞—Å—Å—ã–ª–∫–∞ –æ—Ç–º–µ–Ω–µ–Ω–∞.")
    await send_admin_menu(call)
